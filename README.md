# Articulation-Point-in-Python

My goal in this repository is to generate a Python program to identify Articulation Points in an undirected graph. Articulation points are nodes which increase the number of discrete connected graphs when they are removed and tend to indicate bottlenecks in the graph. 


I recently became interested in graph theory because of internet claims about the advantages of graph databases. I have also been involved with processing survey data from the local community using Python and Pandas. So I’ve been wondering about using Python to process graphs, which has led me to watching youtube presentations about graph theory. One of the more interesting youtube videos I have encountered is William Fiset's graph theory presentation in [freeCodeCamp.org](www.freeCodeCamp.org), titled [“Algorithms Course – Graph Theory Tutorial from a Google Engineer”](https://www.youtube.com/watch?v=09_LlHjoEiY). He has obviously spent a great amount of effort and the results are really fascinating. I have seen shortest path algorithms and minimal spanning trees before, but the section on bridges and articulation points really peaked my interest, especially because it could easily be useful for looking at graph databases. 


His source code is implemented in Java, which I have never liked, so I decided to try implementing his pseudo code in Python. I understand what bridges and articulation points are supposed to be, but I had trouble understanding exactly what lowlink values were.  The video and the associated pdf from github indicate that the lowlink value of a node is the “smallest [lowest] id reachable from that node using forward and backward edges”. When I look at an undirected graph, it seems to me that I can reach any node I wish using forward and backward edges. My work with Python has led me to believe that the lowlink value of a node is really the lowest node reached after that node during a Depth First Search (DFS). The fact that the lowlink value of a node depends on doing a DFS puts a big constraint on the lowest node which can be reached.  The lowlink value of a node is initialized to the same value as the id. If an edge is found to an already visited node during a DFS, then a loop has been found and the lowlink value of the nodes in the loop will be reduced. The lowlink value of all the nodes in a loop tend to be the id of the node with the smallest id in the loop. The issue becomes interesting when a node is contained in more than one loop, but the lowlink value is the smallest node id in a loop which contains the node. Otherwise, the lowlink value remains the same as the id of the node. Articulation points do not occur in loops because the lowlink value being propagated back through the loop is typically smaller than the node id's in the loop. On the other hand, articulation points are found in a line because the node id is smaller than the lowlink value of the next node in the line. 


The first issue I encountered while implementing the pseudocode was that he mentioned in the video that he transformed the graph into a directed graph. I did not understand how I was supposed to transform an undirected graph into a directed graph. The problem was that I could not see an easy way to decide whether to remove the forward link or the backward link because I could easily create a node which could not be reached during a DFS, sort of like an intersection with only oneway roads going away from the intersection. I couldn’t just remove links to lower nodes because one may be needed to detect a loop. I started by naming the nodes of a graph in an order which looked like a DFS and entered the edges from each node to nodes with larger id’s. I generated a graph as a Python dictionary and entered the edges as both forward and backward links. After some experimenting, I decided that the appropriate way to transform the graph into a directed graph was to remove the reverse link when a link was used during the DFS. 


William Fiset kept track of the parent node during each transition of the DFS. He effectively turned the graph into a directed graph by ignoring any link back to a parent node. He also incremented an outEdgeCount for the root node whenever the parent was the root node. Although the approach does work, keeping track of the parent node during the DFS is not really necessary. The graph can be turned into a directed graph by removing the reverse link back to the parent, an easy step in Python, and the outEdgeCount can easily be maintained by simply incrementing the count when a transition is made from the root node. The only other change needed for implementing the algorithm in Python is that the id and the outEdgeCount must be included as parameters because the function is recursive. The resulting pseudocode and a python implementation are included in this repository. The python implementation includes several test cases to demonstrate that the algorithm works. 


The interesting thing I found was that it is not necessary to transform the graph into a directed graph. The algorithm for finding articulation points seems to work just as well for an undirected graph. The difference is that every two successive nodes in the DFS form a loop because there exists both a forward and a reverse link. The result is that the lowlink value of a node tends to be the id of the previous node because the reverse link is a link to an already visited node and the id of the previous node propagates around the loop to the next node. Graphs are essentially loops and lines. The lowlink value of a node tends to be the smallest node id of a loop containing the node, and the lowlink value of a node in a line tends to be the id of the previous node in the line. The logic for detecting the articulation points remains the same and seems to work fine. The Python implementation allows the user to choose whether to transform the graph into a directed graph or leave it as an undirected graph. The test cases demonstrate that the articulation points are correctly found whether the graph is directed or undirected. There may exist some pathological case where the approach does not work for an undirected graph, but I have been unable to find it. 


## Links
- [William Fiset's “Algorithms Course – Graph Theory Tutorial from a Google Engineer”](https://www.youtube.com/watch?v=09_LlHjoEiY)
- [Free Code Camp](www.freecodecamp.org)